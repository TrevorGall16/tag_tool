Document 5: Database & Data Schema (TagArchitect â€” FINAL & COMPLETE)

## 1. Document Purpose

This document defines the complete PostgreSQL database schema for TagArchitect using Prisma ORM. It ensures:

- **ACID Compliance:** Credit transactions are atomic (never lost or double-spent)
- **Data Privacy:** Free user data in localStorage, paid user data in database
- **Automatic Cleanup:** Metadata deleted after 24 hours (privacy + performance)
- **Referential Integrity:** Cascading deletes when batches expire
- **Type Safety:** Enums for status fields, validation constraints

---

## 2. Database Architecture Overview

### 2.1 Entity Relationship Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    User     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 1:N
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   Batch     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜               â”‚
       â”‚                      â”‚ SessionId (free users)
       â”‚ 1:N                  â”‚ or UserId (paid users)
       â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
â”‚    Group    â”‚        â”‚CreditsLedgerâ”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 1:N
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  ImageItem  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Storage Strategy by User Tier

| User Tier                | Batch Storage | Persistence | Cross-Device |
| ------------------------ | ------------- | ----------- | ------------ |
| **Free (Not Logged In)** | localStorage  | 24 hours    | âŒ No        |
| **Free (Logged In)**     | Database      | 24 hours    | âœ… Yes       |
| **Starter/Pro**          | Database      | 24 hours    | âœ… Yes       |

**Implementation:**

- Free users (not logged in): Batch data in browser localStorage, synced on page load
- All logged-in users: Batch data in PostgreSQL database
- Cleanup cron: Deletes expired batches regardless of storage location

---

## 3. Prisma Schema (Complete)

### 3.1 schema.prisma File

**Location:** `/prisma/schema.prisma`

```prisma
// Prisma Schema for TagArchitect
// Database: PostgreSQL
// ORM: Prisma 5.10+

generator client {
  provider      = "prisma-client-js"
  engineType    = "library"
  binaryTargets = ["native", "rhel-openssl-3.0.x"] // REQUIRED for Netlify
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl = env("DIRECT_URL") // Uncomment if using Supabase
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id        String   @id @default(uuid())
  email     String   @unique @db.VarChar(255)

  // Subscription & Credits
  creditsBalance       Int      @default(10) // Initial free credits
  subscriptionTier     SubscriptionTier @default(FREE)

  // Stripe Integration
  stripeCustomerId     String?  @unique @db.VarChar(255)
  stripeSubscriptionId String?  @unique @db.VarChar(255)
  subscriptionStatus   SubscriptionStatus? // active, past_due, canceled, etc.
  subscriptionEndsAt   DateTime? // When subscription period ends

  // Relations
  batches       Batch[]
  creditsLedger CreditsLedger[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([stripeCustomerId])
}

// Enums for User
enum SubscriptionTier {
  FREE
  STARTER  // â‚¬12/month, 200 credits
  PRO      // â‚¬29/month, 1000 credits
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  INCOMPLETE
}

// ============================================================================
// BATCH (SESSION CONTAINER)
// ============================================================================

model Batch {
  id String @id @default(uuid())

  // Ownership
  userId    String? // Null for free (not logged in) users
  user      User?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  sessionId String? @db.VarChar(100) // For free users (stored in localStorage)

  // Configuration
  marketplace Marketplace @default(ADOBE_STOCK)
  status      BatchStatus @default(PENDING)

  // Relations
  groups Group[]

  // Lifecycle
  createdAt DateTime @default(now())
  expiresAt DateTime // Set to createdAt + 24 hours

  @@index([userId])
  @@index([sessionId])
  @@index([expiresAt]) // For cleanup cron job
}

// Enums for Batch
enum Marketplace {
  ADOBE_STOCK
  ETSY
}

enum BatchStatus {
  PENDING      // Just created, no images uploaded yet
  UPLOADING    // Images being uploaded
  CLUSTERING   // CLIP clustering in progress
  TAGGING      // AI generating tags
  VERIFYING    // User reviewing/editing tags
  COMPLETED    // Ready for export
  EXPORTED     // ZIP downloaded
  ERROR        // Something went wrong
}

// ============================================================================
// GROUP (CLUSTER OF SIMILAR IMAGES)
// ============================================================================

model Group {
  id String @id @default(uuid())

  // Ownership
  batchId String
  batch   Batch  @relation(fields: [batchId], references: [id], onDelete: Cascade)

  // Group Properties
  groupNumber Int    // Display order: Group 1, Group 2, etc.
  isVerified  Boolean @default(false) // User confirmed tags are correct

  // Shared Tags (all images in group inherit these)
  sharedTags Json // Array of strings, e.g., ["sunset", "beach", "ocean"]

  // Relations
  images ImageItem[]

  // Timestamps
  createdAt DateTime @default(now())

  @@index([batchId])
  @@unique([batchId, groupNumber]) // Prevent duplicate group numbers in same batch
}

// ============================================================================
// IMAGE ITEM (INDIVIDUAL ASSET)
// ============================================================================

model ImageItem {
  id String @id @default(uuid())

  // Ownership
  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // File Information
  originalFilename String   @db.VarChar(500) // e.g., "IMG_1234.jpg"
  sanitizedSlug    String   @db.VarChar(500) // e.g., "sunset-beach-waves"
  fileSize         Int      // Bytes
  mimeType         String   @db.VarChar(100) // "image/jpeg", "image/png"

  // Thumbnail (stored as data URL in database for 24 hours)
  thumbnailDataUrl String?  @db.Text // Base64 WebP, <512px

  // AI-Generated Metadata
  aiTitle      String? @db.VarChar(500)
  aiTags       Json?   // Array of strings from Claude Vision
  aiConfidence Float?  // 0.0 to 1.0

  // User-Edited Metadata (overrides AI)
  userTitle String? @db.VarChar(500)
  userTags  Json?   // Array of strings, manually edited

  // Status
  status ImageStatus @default(PENDING)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([groupId])
}

// Enums for ImageItem
enum ImageStatus {
  PENDING    // Not yet processed
  CLUSTERING // Being analyzed by CLIP
  TAGGED     // AI tags generated
  VERIFIED   // User confirmed tags
  ERROR      // AI tagging failed
}

// ============================================================================
// CREDITS LEDGER (AUDIT LOG)
// ============================================================================

model CreditsLedger {
  id String @id @default(uuid())

  // Ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Transaction Details
  amount Int    // Positive for purchases, negative for usage
  reason CreditReason

  // Metadata
  stripeSessionId String? @db.VarChar(255) // If purchased via Stripe
  description     String? @db.Text         // Optional notes

  // Timestamp
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

// Enums for CreditsLedger
enum CreditReason {
  PURCHASE      // User bought credits via Stripe
  SUBSCRIPTION  // Monthly subscription renewal
  USAGE         // Used credits for AI tagging
  REFUND        // Credit refunded (e.g., API failure)
  BONUS         // Promotional credits
  ADMIN_ADJUST  // Manual adjustment by admin
}
```

---

## 4. Data Lifecycle & Business Logic

### 4.1 Batch Creation Flow

**Step 1: User Uploads Images**

**Free User (Not Logged In):**

```typescript
// Store batch in localStorage
const batchData = {
  id: uuid(),
  sessionId: generateSessionId(), // Random string
  marketplace: "adobe",
  status: "uploading",
  groups: [],
  createdAt: new Date().toISOString(),
  expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
};
localStorage.setItem("tagarchitect_batch", JSON.stringify(batchData));
```

**Logged-In User:**

```typescript
// Create batch in database
const batch = await prisma.batch.create({
  data: {
    userId: session.user.id,
    marketplace: "ADOBE_STOCK",
    status: "UPLOADING",
    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
  },
});
```

**Step 2: CLIP Clustering**

- Groups created based on CLIP embeddings
- Each group gets sequential `groupNumber` (1, 2, 3...)

**Step 3: AI Tagging**

- For each group, representative image sent to Claude Vision API
- Tags stored in `Group.sharedTags`
- All images in group inherit these tags
- User can override individual image tags via `ImageItem.userTags`

**Step 4: Verification**

- User reviews tags in VerificationGrid
- Marks groups as verified: `Group.isVerified = true`

**Step 5: Export**

- Generate CSV from `ImageItem` data
- Create ZIP with renamed files
- Update batch status: `BatchStatus.EXPORTED`

### 4.2 Credit Deduction (Atomic Transaction)

**Problem:** If server crashes mid-tagging, credits could be deducted without tags being saved.

**Solution:** Use Prisma transactions.

```typescript
// app/api/vision/route.ts
export async function POST(req: Request) {
  const { imageIds, userId } = await req.json();

  // Check balance first (outside transaction)
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { creditsBalance: true },
  });

  if (user.creditsBalance < imageIds.length) {
    return new Response("Insufficient credits", { status: 402 });
  }

  // Atomic transaction: Deduct credits + Save tags
  const result = await prisma.$transaction(async (tx) => {
    // 1. Deduct credits
    const updatedUser = await tx.user.update({
      where: { id: userId },
      data: { creditsBalance: { decrement: imageIds.length } },
    });

    // 2. Log transaction
    await tx.creditsLedger.create({
      data: {
        userId: userId,
        amount: -imageIds.length,
        reason: "USAGE",
        description: `Tagged ${imageIds.length} images`,
      },
    });

    // 3. Call Claude API and save tags
    const tags = await claudeVisionAPI(imageIds);

    // 4. Update image items
    for (const [id, tagData] of Object.entries(tags)) {
      await tx.imageItem.update({
        where: { id },
        data: {
          aiTags: tagData.tags,
          aiTitle: tagData.title,
          aiConfidence: tagData.confidence,
          status: "TAGGED",
        },
      });
    }

    return { success: true, creditsRemaining: updatedUser.creditsBalance };
  });

  return Response.json(result);
}
```

**Key Points:**

- Entire operation wrapped in `prisma.$transaction`
- If ANY step fails â†’ rollback (credits not deducted, tags not saved)
- Ledger entry created for audit trail

### 4.3 24-Hour Cleanup (Netlify Scheduled Function)

**Implementation:** Netlify Scheduled Functions (Background Task)

**File Location:** `/netlify/functions/cleanup-cron.ts`

**Code:**

```typescript
import { schedule } from "@netlify/functions";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export const handler = schedule("0 * * * *", async (event) => {
  const now = new Date();

  try {
    // Delete expired batches (cascades to groups and images)
    const deleteResult = await prisma.batch.deleteMany({
      where: {
        expiresAt: { lt: now },
      },
    });

    console.log(`[Netlify Cron] Success: Deleted ${deleteResult.count} expired batches.`);
    return { statusCode: 200 };
  } catch (error) {
    console.error("[Netlify Cron] Error:", error);
    return { statusCode: 500 };
  }
});
```

**NetlifyConfiguration (`netlify.toml`):**

```json
{
  "crons": [
    {
      "path": "/api/cron/cleanup",
      "schedule": "0 * * * *"
    }
  ]
}
```

**Schedule:** Runs every hour (at minute 0)

**Security:**

- Cron route protected by bearer token (`CRON_SECRET` env variable)
- Only Netlify's cron service has this token

**Fallback (Manual Cleanup):**

If cron fails, add a cleanup trigger to `/dashboard` page load:

```typescript
// app/dashboard/page.tsx (server component)
export default async function DashboardPage() {
  // Clean up expired batches on page load (fallback)
  await prisma.batch.deleteMany({
    where: { expiresAt: { lt: new Date() } },
  });

  // ... rest of page
}
```

### 4.4 Stripe Webhook (Credit Purchase)

**File: `/app/api/stripe/webhook/route.ts`**

```typescript
import Stripe from "stripe";
import { prisma } from "@/lib/prisma";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function POST(req: Request) {
  const body = await req.text();
  const sig = req.headers.get("stripe-signature")!;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (err) {
    return new Response("Webhook signature verification failed", { status: 400 });
  }

  // Handle checkout.session.completed
  if (event.type === "checkout.session.completed") {
    const session = event.data.object as Stripe.Checkout.Session;

    const userId = session.metadata?.user_id;
    const creditsAmount = parseInt(session.metadata?.credits || "0");
    const tier = session.metadata?.tier as SubscriptionTier;

    if (!userId || !creditsAmount) {
      return new Response("Missing metadata", { status: 400 });
    }

    // Atomic: Update credits + Create ledger entry + Update subscription
    await prisma.$transaction([
      // 1. Add credits
      prisma.user.update({
        where: { id: userId },
        data: {
          creditsBalance: { increment: creditsAmount },
          subscriptionTier: tier,
          stripeCustomerId: session.customer as string,
          stripeSubscriptionId: session.subscription as string,
          subscriptionStatus: "ACTIVE",
          subscriptionEndsAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // +30 days
        },
      }),

      // 2. Log purchase
      prisma.creditsLedger.create({
        data: {
          userId: userId,
          amount: creditsAmount,
          reason: tier === "FREE" ? "PURCHASE" : "SUBSCRIPTION",
          stripeSessionId: session.id,
          description: `Purchased ${tier} plan`,
        },
      }),
    ]);
  }

  // Handle subscription cancellation
  if (event.type === "customer.subscription.deleted") {
    const subscription = event.data.object as Stripe.Subscription;

    await prisma.user.update({
      where: { stripeSubscriptionId: subscription.id },
      data: {
        subscriptionTier: "FREE",
        subscriptionStatus: "CANCELED",
      },
    });
  }

  return Response.json({ received: true });
}
```

---

## 5. Database Indexes (Performance Optimization)

### 5.1 Query Patterns

**Most Common Queries:**

1. Find user by email (login)
2. Find batches by userId (dashboard)
3. Find expired batches (cleanup cron)
4. Find images by groupId (rendering VerificationGrid)
5. Find credits ledger by userId (transaction history)

### 5.2 Index Strategy

**Already Defined in Schema:**

```prisma
// User indexes
@@index([email])
@@index([stripeCustomerId])

// Batch indexes
@@index([userId])
@@index([sessionId])
@@index([expiresAt]) // Critical for cleanup cron

// Group indexes
@@index([batchId])
@@unique([batchId, groupNumber])

// ImageItem indexes
@@index([groupId])

// CreditsLedger indexes
@@index([userId])
@@index([createdAt])
```

**Performance Impact:**

- Without indexes: Cleanup query scans entire `Batch` table (slow)
- With `expiresAt` index: Query uses index (fast, <10ms)

---

## 6. Validation Rules & Constraints

### 6.1 Field Length Limits

| Field                        | Max Length | Rationale                                  |
| ---------------------------- | ---------- | ------------------------------------------ |
| `User.email`                 | 255 chars  | RFC 5321 standard                          |
| `ImageItem.originalFilename` | 500 chars  | Supports long paths                        |
| `ImageItem.sanitizedSlug`    | 500 chars  | Same as filename                           |
| `ImageItem.aiTitle`          | 500 chars  | Marketplace limits (Adobe: 200, Etsy: 140) |
| `Batch.sessionId`            | 100 chars  | UUID + prefix                              |

### 6.2 JSON Field Structure

**Group.sharedTags:**

```json
["sunset", "beach", "ocean", "waves", "vacation"]
```

**ImageItem.aiTags:**

```json
["sunset", "beach", "tropical", "paradise"]
```

**ImageItem.userTags (if edited):**

```json
["sunset", "ocean", "travel"]
```

**Validation (Application Layer):**

```typescript
// Ensure tags are array of strings, max 49 for Adobe Stock
function validateTags(tags: any, marketplace: Marketplace): boolean {
  if (!Array.isArray(tags)) return false;
  if (tags.length === 0) return false;

  const maxTags = marketplace === "ADOBE_STOCK" ? 49 : 13;
  if (tags.length > maxTags) return false;

  return tags.every((tag) => typeof tag === "string" && tag.length <= 50);
}
```

---

## 7. Migration Strategy

### 7.1 Initial Migration

**Step 1: Generate Migration**

```bash
pnpm prisma migrate dev --name init
```

**Step 2: Review Migration File**
Check `/prisma/migrations/YYYYMMDDHHMMSS_init/migration.sql`

**Step 3: Apply to Production**

```bash
pnpm prisma migrate deploy
```

### 7.2 Schema Changes (Post-Launch)

**Example: Adding a new field**

```bash
# 1. Edit schema.prisma
# Add: User.emailVerified Boolean @default(false)

# 2. Generate migration
pnpm prisma migrate dev --name add_email_verified

# 3. Test locally
pnpm dev

# 4. Deploy to production
pnpm prisma migrate deploy
```

**Rollback Strategy:**

Prisma doesn't support automatic rollbacks. If migration fails:

1. Manually revert database using SQL
2. Remove migration file from `/prisma/migrations/`
3. Fix schema, create new migration

---

## 8. Seed Data (Testing)

### 8.1 seed.ts File

**Location:** `/prisma/seed.ts`

```typescript
import { PrismaClient, SubscriptionTier, Marketplace } from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
  console.log("ğŸŒ± Seeding database...");

  // 1. Create test users
  const freeUser = await prisma.user.create({
    data: {
      email: "free@example.com",
      creditsBalance: 5,
      subscriptionTier: "FREE",
    },
  });

  const starterUser = await prisma.user.create({
    data: {
      email: "starter@example.com",
      creditsBalance: 200,
      subscriptionTier: "STARTER",
      stripeCustomerId: "cus_test123",
      subscriptionStatus: "ACTIVE",
    },
  });

  const proUser = await prisma.user.create({
    data: {
      email: "pro@example.com",
      creditsBalance: 1000,
      subscriptionTier: "PRO",
      stripeCustomerId: "cus_test456",
      subscriptionStatus: "ACTIVE",
    },
  });

  // 2. Create active batch with groups
  const activeBatch = await prisma.batch.create({
    data: {
      userId: starterUser.id,
      marketplace: "ADOBE_STOCK",
      status: "VERIFYING",
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // +24 hours
      groups: {
        create: [
          {
            groupNumber: 1,
            isVerified: false,
            sharedTags: ["sunset", "beach", "ocean", "waves"],
            images: {
              create: [
                {
                  originalFilename: "IMG_0001.jpg",
                  sanitizedSlug: "sunset-beach-waves",
                  fileSize: 2048000,
                  mimeType: "image/jpeg",
                  aiTitle: "Sunset Beach with Waves",
                  aiTags: ["sunset", "beach", "ocean", "waves", "tropical"],
                  aiConfidence: 0.92,
                  status: "TAGGED",
                },
                {
                  originalFilename: "IMG_0002.jpg",
                  sanitizedSlug: "sunset-beach-calm",
                  fileSize: 1920000,
                  mimeType: "image/jpeg",
                  aiTitle: "Calm Beach at Sunset",
                  aiTags: ["sunset", "beach", "calm", "peaceful"],
                  aiConfidence: 0.88,
                  status: "TAGGED",
                },
              ],
            },
          },
          {
            groupNumber: 2,
            isVerified: true,
            sharedTags: ["mountains", "landscape", "nature"],
            images: {
              create: [
                {
                  originalFilename: "IMG_0010.jpg",
                  sanitizedSlug: "mountain-landscape",
                  fileSize: 3200000,
                  mimeType: "image/jpeg",
                  aiTitle: "Mountain Landscape",
                  aiTags: ["mountains", "landscape", "nature", "hiking"],
                  aiConfidence: 0.95,
                  status: "VERIFIED",
                },
              ],
            },
          },
        ],
      },
    },
  });

  // 3. Create expired batch (for testing cleanup)
  const expiredBatch = await prisma.batch.create({
    data: {
      userId: freeUser.id,
      marketplace: "ETSY",
      status: "COMPLETED",
      createdAt: new Date(Date.now() - 25 * 60 * 60 * 1000), // 25 hours ago
      expiresAt: new Date(Date.now() - 1 * 60 * 60 * 1000), // 1 hour ago
    },
  });

  // 4. Create credits ledger entries
  await prisma.creditsLedger.createMany({
    data: [
      {
        userId: starterUser.id,
        amount: 200,
        reason: "SUBSCRIPTION",
        description: "Starter plan monthly credits",
      },
      {
        userId: starterUser.id,
        amount: -10,
        reason: "USAGE",
        description: "Tagged 10 images",
      },
      {
        userId: proUser.id,
        amount: 1000,
        reason: "SUBSCRIPTION",
        description: "Pro plan monthly credits",
      },
    ],
  });

  console.log("âœ… Seed data created:");
  console.log(`  - Free User: ${freeUser.email} (${freeUser.creditsBalance} credits)`);
  console.log(`  - Starter User: ${starterUser.email} (${starterUser.creditsBalance} credits)`);
  console.log(`  - Pro User: ${proUser.email} (${proUser.creditsBalance} credits)`);
  console.log(`  - Active Batch: ${activeBatch.id} (2 groups, 3 images)`);
  console.log(`  - Expired Batch: ${expiredBatch.id} (for cleanup testing)`);
}

main()
  .catch((e) => {
    console.error("âŒ Seed failed:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Run Seed:**

```bash
pnpm prisma db seed
```

**package.json:**

```json
{
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  }
}
```

---

## 9. Database Backup Strategy

### 9.1 Automatic Backups (Supabase/Neon)

**Supabase:**

- Daily automatic backups (free tier: 7 days retention)
- Point-in-time recovery (paid tiers)

**Neon:**

- Branch-based backups (every deployment creates a branch)
- Manual snapshots available

### 9.2 Manual Backup (PostgreSQL)

```bash
# Dump entire database
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d).sql

# Restore from backup
psql $DATABASE_URL < backup_20250119.sql
```

### 9.3 What to Backup

**Critical Data:**

- Users table (account info)
- CreditsLedger (transaction history)

**Non-Critical Data:**

- Batches (expire after 24 hours anyway)
- Groups, ImageItems (deleted automatically)

**Recommendation:** Daily backup of Users + CreditsLedger only.

---

## 10. Data Privacy & GDPR Compliance

### 10.1 User Data Deletion

**User Requests Account Deletion:**

```typescript
// app/api/account/delete/route.ts
export async function DELETE(req: Request) {
  const session = await getServerSession();
  if (!session) return new Response("Unauthorized", { status: 401 });

  const userId = session.user.id;

  // Delete user (cascades to batches, ledger)
  await prisma.user.delete({
    where: { id: userId },
  });

  // Cancel Stripe subscription
  if (session.user.stripeSubscriptionId) {
    await stripe.subscriptions.cancel(session.user.stripeSubscriptionId);
  }

  return Response.json({ message: "Account deleted" });
}
```

**Cascade Behavior:**

- Deleting User â†’ Deletes all Batches (onDelete: Cascade)
- Deleting Batch â†’ Deletes all Groups â†’ Deletes all ImageItems

### 10.2 Data Retention Policy

**Privacy Policy Statement:**

> "We store your uploaded image metadata for 24 hours to enable batch processing. After 24 hours, all metadata (tags, filenames, thumbnails) is automatically deleted. High-resolution images are never uploaded to our serversâ€”they remain in your browser only."

### 10.3 No Sensitive Data in Database

**What we store:**

- âœ… Email address
- âœ… Credits balance
- âœ… Image metadata (titles, tags)
- âœ… Thumbnails (base64, <512px)

**What we DON'T store:**

- âŒ High-resolution images (never leave browser)
- âŒ Credit card numbers (handled by Stripe)
- âŒ Passwords (use NextAuth with hashing)

---

## 11. Testing Checklist

### 11.1 Schema Validation

Before deploying:

- [ ] Run `pnpm prisma validate` (no errors)
- [ ] Run `pnpm prisma migrate dev` (migration succeeds)
- [ ] Run `pnpm prisma db seed` (seed data created)
- [ ] Check all enum values match TypeScript types

### 11.2 Business Logic Testing

**Test Cases:**

1. **Credit Deduction:**
   - Start with 10 credits
   - Tag 5 images
   - Balance should be 5 (not 10, not 0)

2. **Transaction Rollback:**
   - Simulate API failure mid-transaction
   - Credits should NOT be deducted
   - Tags should NOT be saved

3. **24-Hour Cleanup:**
   - Create batch with `expiresAt` = 1 hour ago
   - Run cron job
   - Batch should be deleted

4. **Cascade Deletion:**
   - Delete user
   - All batches, groups, images should be deleted

5. **Duplicate Prevention:**
   - Try creating Group with same `batchId` + `groupNumber`
   - Should fail (unique constraint)

### 11.3 Performance Testing

**Load Test:**

- 1,000 users concurrently accessing dashboard
- Batch queries should use userId index (<10ms)
- Cleanup cron should use expiresAt index (<50ms for 10,000 batches)

---

## 12. Environment Variables

### 12.1 Required Variables

**`.env` file:**

```bash
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/tagarchitect"

# Stripe
STRIPE_SECRET_KEY="sk_test_..."
STRIPE_WEBHOOK_SECRET="whsec_..."

# Cron Job Security
CRON_SECRET="random-32-character-string"

# NextAuth
NEXTAUTH_SECRET="random-32-character-string"
NEXTAUTH_URL="http://localhost:3000"

# Anthropic API
ANTHROPIC_API_KEY="sk-ant-api03-..."
```

### 12.2 Production Setup

**NetlifyEnvironment Variables:**

- Add all variables in Netlifydashboard
- Use different `DATABASE_URL` for production (Supabase/Neon)
- Use production Stripe keys (`sk_live_...`)

---

## 13. Summary: Database Architecture

| Aspect           | Decision                                              |
| ---------------- | ----------------------------------------------------- |
| **Database**     | PostgreSQL (via Supabase or Neon)                     |
| **ORM**          | Prisma 5.10+                                          |
| **Tables**       | User, Batch, Group, ImageItem, CreditsLedger          |
| **Indexes**      | userId, sessionId, expiresAt, email                   |
| **Cleanup**      | NetlifyCron (hourly), deletes batches after 24 hours  |
| **Transactions** | Atomic credit deduction + tag saving                  |
| **Privacy**      | Auto-delete after 24 hours, no high-res images stored |
| **Backup**       | Daily backup (Users + CreditsLedger only)             |
| **GDPR**         | User deletion cascades to all related data            |

---
